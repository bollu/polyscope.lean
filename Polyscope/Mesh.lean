import ProofWidgets.Component.HtmlDisplay
open Lean ProofWidgets

/-- A mesh with vertex and face data. -/
structure MeshProps where
  vertices : Array Float
  faces : Array Nat
deriving Server.RpcEncodable, Inhabited

@[widget_module]
def Mesh : Component MeshProps where
  javascript := include_str "../build" / "js" / "mesh.js"


/- Random mesh generation -/

/-- Generate a random floating point number in [0, 1] -/
def randFloat01 [G : RandomGen γ] (gen : γ) : Float × γ := Id.run do do
  let (val, gen) := G.next gen
  let (lo, hi) := G.range gen
  return ((Float.ofNat <| val - lo) / (Float.ofNat <| hi - lo), gen)

/-- Create a random vertex with coordinates sampled from uniform [0, 1] -/
def randVertex01 [RandomGen γ] (gen : γ) : (Array Float) × γ := Id.run do
  let (val1, gen) := randFloat01 gen
  let (val2, gen) := randFloat01 gen
  let (val3, gen) := randFloat01 gen
  return (#[val1, val2, val3], gen)


/-- Create `nvertices` random vertices with coordinates sampled from [-scale/2, scale/2] -/
def randVertices [RandomGen γ] (gen : γ) (nvertices : Nat) (scale : Float := 10) : (Array Float) × γ := Id.run do
  let mut out : Array Float := #[]
  let mut gen := gen
  for _ in List.range nvertices do
    let (vertex, gen') := randVertex01 gen; gen := gen'
    let vertex := vertex.map (fun coord => (coord - 0.5) * scale)
    out := out.append vertex
  return (out, gen)


/-- Create a random triangle face with three random vertices with indexes `[0..nvertices)` -/
def randTriFace [RandomGen γ] (gen : γ) (nvertices : Nat) : (Array Nat) × γ := Id.run do
  let (v1, gen) := randNat gen 0 (nvertices-1);
  let (v2, gen) := randNat gen 0 (nvertices-1);
  let (v3, gen) := randNat gen 0 (nvertices-1);
  return (#[v1, v2, v3], gen)

/-- Create a random mesh with `nfaces` random faces. Each face is generated by `randTriFace` -/
def randTriFaces [RandomGen γ] (gen : γ) (nvertices : Nat) (nfaces : Nat) : (Array Nat) × γ := Id.run do
  let mut out : Array Nat := #[]
  let mut gen := gen
  for _ in List.range nfaces do
    let (face, gen') := randTriFace gen nvertices; gen := gen'
    out := out.append face
  return (out, gen)

/-- Create a random mesh with `nvertices` vertices and `nfaces` faces -/
def MeshProps.rand [RandomGen γ] (gen : γ) (nvertices : Nat) (nfaces : Nat) : MeshProps × γ := Id.run do
  let (vs, gen) := randVertices gen nvertices
  let (fs, gen) := randTriFaces gen nvertices nfaces
  return ({ vertices := vs, faces := fs : MeshProps }, gen)


/- Load the mesh data from a .OFF format string -/
def MeshProps.fromOFFString [Monad m] [MonadExceptOf String m] (lines : Array String) : m MeshProps := do
  let mut vertices : Array Float := #[]
  let mut faces : Array Nat := #[]
  let mut i := 0
  if lines[i]!.trim != "OFF"
  then throw s!"expected 'OFF' on line {i+1}. but found '{lines[i]!}' which is not .OFF"
  i := i + 1

  let [n_vertices, n_faces, _n_edges] := lines[i]!.trim.splitOn " "
    | throw s!"expected number of vertices, faces, edges information on line {i+1}, but found '{lines[i]!}'"
  i := i + 1

  let .some n_vertices := n_vertices.toNat?
    | throw s! "unable to parse num vertices {n_vertices}"

  let .some n_faces := n_faces.toNat?
    | throw s! "unable to parse num faces {n_faces}"

  for _ in List.range n_vertices do
    let coords_raw := lines[i]!.trim.splitOn " "
    let mut v : Array Float := #[]
    for coord in coords_raw do
      let .ok coord := Lean.Json.Parser.num |>.run coord
        | throw s!"unable to parse vertex coordinate {coord} on line {i+1}"
        v := v.push coord.toFloat
    vertices := vertices.append v
    i := i + 1

  for _ in List.range n_faces do
    let face_indexes_raw := lines[i]!.trim.splitOn " "
    let mut f : Array Nat := #[]
    for ix in face_indexes_raw.drop 1 do
      let .some ix := ix.toNat?
        | throw s!"unable to parse face index {ix} on line {i+1}"
        f := f.push ix
    faces := faces.append f
    i := i + 1

  return { vertices := vertices, faces := faces : MeshProps }

/-- Load a mesh from the file path p -/
def MeshProps.fromOFFFile (p : System.FilePath) : IO MeshProps := do
  let out : Except String MeshProps := MeshProps.fromOFFString (← IO.FS.lines p)
  match out with
  | .ok out => return out
  | .error err => throw <| .userError err
